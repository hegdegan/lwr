import { getMappingUriPrefix, getModuleUriPrefix, getClientBootstrapConfigurationUri, hashContent, getVersionedModuleId, normalizeVersionToUri, logger, VERSION_NOT_PROVIDED, explodeSpecifier, getSpecifier, } from '@lwrjs/shared-utils';
const CONTENT_TYPE = 'application/javascript';
export function getViewBootstrapConfigurationResource(viewInfo, config, runtimeEnvironment, runtimeParams) {
    const { compat, debug, hmrEnabled, apiVersion, format } = runtimeEnvironment;
    const isESM = format === 'esm';
    const defaultUrl = getModuleUriPrefix(runtimeEnvironment, runtimeParams);
    const mapping = getMappingUriPrefix(runtimeEnvironment, runtimeParams);
    const endpoints = {
        uris: {
            mapping,
            // TODO: DBL Should the ESM rely directly on the module endpoint?  why not use the mapping endpoint as well?
            ...(isESM && { module: defaultUrl }),
            ...(isESM &&
                hmrEnabled && {
                hmr: `/${apiVersion}/hmr/${format}/${compat}?${debug ? 'debug=true' : ''}`,
            }),
        },
        ...(debug && { modifiers: { debug: 'true' } }),
    };
    const configString = [
        '/* This script is generated */',
        '/* Client Bootstrap configuration */',
        `globalThis.LWR = globalThis.LWR || {};`,
        `Object.assign(globalThis.LWR, ${JSON.stringify({
            ...config,
            endpoints,
        })});`,
        // TODO: W-12639529 change after addressing downstream customers
        `globalThis.process = { env: { NODE_ENV: "${runtimeEnvironment.serverMode}" } };`,
    ]
        .filter(Boolean)
        .join('\n');
    if (viewInfo.configAsSrc) {
        const viewUrl = viewInfo.url || '/';
        const url = getClientBootstrapConfigurationUri({ id: viewInfo.id, url: viewUrl }, runtimeEnvironment, runtimeParams, hashContent(configString));
        return {
            type: CONTENT_TYPE,
            content: configString,
            inline: false,
            src: url,
        };
    }
    else {
        return {
            type: CONTENT_TYPE,
            content: configString,
            inline: true,
        };
    }
}
export function getViewHmrConfigurationResource(view, viewMetadata) {
    const { assetReferences } = viewMetadata;
    const { contentTemplate, layoutTemplate } = view;
    const refs = assetReferences.map((assetReference) => {
        if (assetReference.override) {
            return assetReference.override?.entry;
        }
    });
    const configString = [
        `
        /* generated View/HMR debug script */
        globalThis._lwrRuntimeDebug = {
            viewMetadata: {
                assetReferences: ${JSON.stringify(refs)},
                templates: ${JSON.stringify([contentTemplate, layoutTemplate].filter(Boolean))}
            }
        }
        `,
        `globalThis.lwcRuntimeFlags = { ENABLE_HMR: true };`,
    ]
        .filter(Boolean)
        .join('\n');
    // Return an inline resource
    return {
        type: CONTENT_TYPE,
        inline: true,
        content: configString,
    };
}
export function flattenCustomElements(arr, isSSR = false) {
    const ret = [];
    const visitedTags = new Set();
    function flatten(arr) {
        for (const val of arr) {
            const { tagName, children, props } = val;
            if (!visitedTags.has(tagName)) {
                if (isSSR) {
                    ret.push({ tagName, props });
                }
                else {
                    ret.push({ tagName });
                }
                visitedTags.add(tagName);
            }
            if (children) {
                flatten(children);
            }
        }
    }
    flatten(arr);
    return ret;
}
/**
 * Recursively gets preloadModules metadata starting with a specifer
 * Note: don't call me unless you got bundles
 */
export async function getPreloadModulesMeta(specifier, // unversioned specifier
preloadModulesMeta, bundleConfig, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, pending) {
    const { exclude = [], external = {} } = bundleConfig;
    const isExternal = function (rawSpecifier) {
        const { specifier } = explodeSpecifier(rawSpecifier);
        return Object.keys(external).includes(specifier);
    };
    const isExclude = function (specifier) {
        return exclude.includes(specifier);
    };
    if (isExternal(specifier)) {
        logger.warn(`"${specifier}" is configured in both bundleConfig.externals and bootstrap.preloadModules. We are treating it as external.`);
    }
    else {
        // eslint-disable-next-line no-await-in-loop
        const versionedModuleId = await getVersionedModuleId(specifier, moduleRegistry); // TODO replace moduleRegistry with defRegistry
        const versionedModuleSpecifier = getSpecifier({
            specifier,
            version: normalizeVersionToUri(versionedModuleId.version),
        });
        const uri = 
        // eslint-disable-next-line no-await-in-loop
        await defRegistry.resolveModuleUri(versionedModuleId, runtimeEnvironment, runtimeParams);
        // fallback to unversioned specifier if needed
        const normalizedSpecifier = versionedModuleId.version === VERSION_NOT_PROVIDED ? specifier : versionedModuleSpecifier;
        preloadModulesMeta.set(normalizedSpecifier, uri);
        if (exclude.length) {
            // check if we need to also preload any excluded dependencies of this preload module
            const preloadModuleRecord = await defRegistry.getModuleBundle(versionedModuleId, runtimeEnvironment, runtimeParams);
            const { imports } = preloadModuleRecord.bundleRecord;
            if (imports) {
                if (!pending) {
                    pending = new Map();
                }
                for (let i = 0; i < imports.length; i++) {
                    const imp = imports[i];
                    if (!pending.has(imp.specifier) && isExclude(imp.specifier)) {
                        pending.set(imp.specifier, true); // prevent dupe calls
                        // eslint-disable-next-line no-await-in-loop
                        await getPreloadModulesMeta(imp.specifier, preloadModulesMeta, bundleConfig, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, pending);
                    }
                }
            }
        }
    }
}
//# sourceMappingURL=utils.js.map