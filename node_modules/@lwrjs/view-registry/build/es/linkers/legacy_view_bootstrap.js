import { kebabCaseToModuleSpecifier, getModuleGraphs, GraphDepth, getModuleUriPrefix, logger, explodeSpecifier, isBundler, } from '@lwrjs/shared-utils';
import { AppResourceEnum, getAppSpecifier } from '@lwrjs/app-service/identity';
import { generateHtmlTag, getModuleResourceByUri } from '../utils.js';
import { flattenCustomElements, getViewBootstrapConfigurationResource, getViewHmrConfigurationResource, getPreloadModulesMeta, } from './utils.js';
export async function getHtmlResources(view, viewParams, resourceContext) {
    const { runtimeEnvironment, runtimeParams, moduleRegistry, moduleBundler, resourceRegistry, viewMetadata, } = resourceContext;
    const { bundleConfig } = resourceContext;
    const { external = {} } = bundleConfig;
    const isExternal = function (rawSpecifier) {
        const { specifier } = explodeSpecifier(rawSpecifier);
        return Object.keys(external).some((e) => specifier === e);
    };
    const { id: appName, bootstrap: { services, module: bootstrapModule, preloadModules = [] } = {
        services: [],
        preloadModules: [],
    }, } = view;
    const { lwrVersion, format, hmrEnabled, bundle, debug, minify } = runtimeEnvironment;
    const { customElements } = viewMetadata;
    const version = lwrVersion;
    const isAMD = format === 'amd';
    // The Application Bootstrap (ABS) module resource is EITHER
    //      - configured as routes[x].bootstrap.module OR
    //      - defaulted as "@lwrjs/app-service/{appName}/module/{format}"
    const appIdentity = {
        appName,
        format: runtimeEnvironment.format,
        resourceType: AppResourceEnum.MODULE,
    };
    const bootstrapSpecifier = bootstrapModule || getAppSpecifier(appIdentity);
    /*
        Internal module and module dependency related resources used by the view to render view related components.
     */
    const moduleResources = [];
    /*
        External resources that the view depends. These resources include ones that an ViewDefinition client are required to load
        in order to view to begin initialization.
     */
    const requiredResources = [];
    /*
        Bootstrap configuration resources -- these resources are specifically exposed as bootstrap.resources in the RenderedViewRecord
     */
    const configResources = [];
    // Cache of visited module flattened graphs
    const visitedCache = new Map();
    // Collection of import URL metadata
    const imports = {};
    // Collection of root view component specifiers
    const rootComponents = [];
    // Collection of modules specifiers that MUST be loaded in the view
    const requiredAmdModules = [];
    // Collection of modules that will be preloaded. For AMD, it will be part of
    // the preloadModules client bootstrap config
    const preloadModulesMeta = new Map();
    // Determine if server side rendering view modules
    const isSSR = view.bootstrap?.ssr;
    // ------ AMD Required module resources
    if (isAMD) {
        // Keep shim format in sync with view_bootstrap.ts
        const shimBundle = debug || minify === false
            ? 'lwr-loader-shim-legacy.bundle.js'
            : 'lwr-loader-shim-legacy.bundle.min.js';
        let def = (await resourceRegistry.getResource({ specifier: shimBundle, version }, runtimeEnvironment, runtimeParams));
        if (!def) {
            // HACK: fallback to looking for the other shim.
            // TODO: remove this once we solve debug mode in MRT
            let fallbackShimBundle;
            if (shimBundle === 'lwr-loader-shim-legacy.bundle.js') {
                fallbackShimBundle = 'lwr-loader-shim-legacy.bundle.min.js';
                def = (await resourceRegistry.getResource({ specifier: fallbackShimBundle, version }, runtimeEnvironment, runtimeParams));
            }
            else {
                fallbackShimBundle = 'lwr-loader-shim-legacy.bundle.js';
                def = (await resourceRegistry.getResource({ specifier: fallbackShimBundle, version }, runtimeEnvironment, runtimeParams));
            }
            // throw if we still can't find it
            if (!def) {
                throw Error('Failed to find definition of resource: ' + shimBundle);
            }
        }
        requiredResources.push(def);
        // Always inline the error shim script after the shim
        const errorShimDef = (await resourceRegistry.getResource({ specifier: 'lwr-error-shim.js', version }, runtimeEnvironment, runtimeParams));
        if (!errorShimDef) {
            throw Error('Failed to find definition of resource: lwr-error-shim.js');
        }
        requiredResources.push(errorShimDef);
    }
    // ------- Application Bootstrap module
    // Traversal of the Bootstrap Module Graph is done to get all the URLS for discoverable static dependencies.
    // Reasoning: This is to avoid unnecessary HTTP 302's during initial application module fetching.
    // Scope: ESM currently only exposes immutable URI references, optimize for AMD formats
    const depth = isAMD
        ? { static: GraphDepth.ALL, dynamic: 1 }
        : { static: GraphDepth.NONE, dynamic: 0 };
    const defRegistry = bundle ? moduleBundler : moduleRegistry;
    const bootstrapModuleGraph = await getModuleGraphs(bootstrapSpecifier, { includeUris: true, includeLinkedDefinitions: true, depth }, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, visitedCache);
    // ADD bootstrap module uri as a script resource
    const versionedSpecifier = bootstrapModuleGraph.graphs[0].specifier;
    const uri = bootstrapModuleGraph.uriMap[versionedSpecifier];
    moduleResources.push(getModuleResourceByUri(uri, runtimeEnvironment, { isPreload: false, isSSR }));
    // PRELOAD the bootstrap module static dependencies as preloaded script resources
    for (const depSpecifier of bootstrapModuleGraph.graphs[0].static) {
        if (!isExternal(depSpecifier)) {
            const uri = bootstrapModuleGraph.uriMap[depSpecifier];
            preloadModulesMeta.set(depSpecifier, uri);
        }
    }
    // PRELOAD configured preloadModules as preloaded script resources
    if (isBundler(defRegistry)) {
        for (const specifier of preloadModules) {
            // eslint-disable-next-line no-await-in-loop
            await getPreloadModulesMeta(specifier, preloadModulesMeta, bundleConfig, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams);
        }
    }
    if (isAMD) {
        // ADD bootstrap module as required
        requiredAmdModules.push(versionedSpecifier);
        // AMD ADD bootstrap module uri addressability
        imports[versionedSpecifier] = uri;
        // PRELOAD bootstrap module static deps as link resource
        for (const staticDep of bootstrapModuleGraph.graphs[0].static) {
            const uri = bootstrapModuleGraph.uriMap[staticDep];
            // AMD ADD static module dep uri addressability
            imports[staticDep] = uri;
            // ADD bootstrap module static deps to requiredAmdModules if services, otherwise preloadModules
            if (services && services.length) {
                requiredAmdModules.push(staticDep);
            }
        }
        // AMD Add import mappings for known dynamic imports
        for (const dynamicDep of bootstrapModuleGraph.graphs[0].dynamicRefs) {
            const uri = bootstrapModuleGraph.uriMap[dynamicDep];
            if (uri) {
                imports[dynamicDep] = uri;
            }
            else {
                logger.warn('Skipping unknown dynamic import ' + dynamicDep);
            }
        }
    }
    // ------- View related custom element moduleResources
    const customElementsRecords = [];
    const flattenedElements = flattenCustomElements(customElements, isSSR);
    await Promise.all(flattenedElements.map(async ({ tagName: element, props }) => {
        const graph = await getModuleGraphs(kebabCaseToModuleSpecifier(element), { includeUris: true, includeLinkedDefinitions: true, depth }, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams ? runtimeParams : {}, visitedCache);
        // add to the viewRecord
        customElementsRecords.push({ elementName: element, flatGraph: graph });
        // PRELOAD the custom element module as a link resource
        const specifier = graph.graphs[0].specifier;
        const uri = graph.uriMap[specifier];
        preloadModulesMeta.set(specifier, uri);
        // PRELOAD custom element static deps as link resources when bundling is ON
        if (bundle) {
            for (const depSpecifier of graph.graphs[0].static) {
                if (!isExternal(depSpecifier)) {
                    const uri = graph.uriMap[depSpecifier];
                    preloadModulesMeta.set(depSpecifier, uri);
                }
            }
        }
        // ADD register custom elements as a uri addressable rootComponents
        rootComponents.push(specifier);
        imports[specifier] = uri;
        if (isAMD) {
            for (const staticDep of graph.graphs[0].static) {
                const uri = graph.uriMap[staticDep];
                // AMD ADD static module dep uri addressability
                imports[staticDep] = uri;
            }
            // AMD ADD dynamic imports module dep uri addressability
            for (const dynamicDep of graph.graphs[0].dynamicRefs) {
                const uri = graph.uriMap[dynamicDep];
                imports[dynamicDep] = uri;
            }
        }
    }));
    // ADD configuration of the bootstrapModule
    configResources.unshift(await getViewBootstrapConfigurationResource({
        id: view.id,
        url: viewParams?.page?.url,
        configAsSrc: view.bootstrap?.configAsSrc || false,
    }, {
        appId: appIdentity.appName,
        bootstrapModule: versionedSpecifier,
        autoBoot: view.bootstrap?.autoBoot === false ? false : true,
        importMappings: {
            imports,
            default: getModuleUriPrefix(runtimeEnvironment, runtimeParams),
        },
        rootComponents,
        ...(isAMD && { requiredModules: requiredAmdModules }),
        // in AMD we need to tell the loader what modules we are preloading
        ...(isAMD && { preloadModules: Array.from(preloadModulesMeta.keys()) }),
    }, runtimeEnvironment, runtimeParams));
    if (!isAMD && hmrEnabled) {
        configResources.unshift(await getViewHmrConfigurationResource(view, viewMetadata));
    }
    // PRELOAD script resources for preload module URIs after the bootstrap module
    for (const [, preloadUri] of preloadModulesMeta) {
        moduleResources.push(getModuleResourceByUri(preloadUri, runtimeEnvironment, { isPreload: true, isSSR }));
    }
    // generate html partial
    const htmlResources = await Promise.all([...configResources, ...requiredResources, ...moduleResources].map(generateHtmlTag));
    return {
        partial: htmlResources.join('\n'),
        viewRecord: {
            resources: requiredResources,
            customElements: customElementsRecords,
            bootstrapModule: {
                specifier: bootstrapModuleGraph.graphs[0].specifier,
                flatGraph: bootstrapModuleGraph,
                resources: configResources,
            },
        },
    };
}
//# sourceMappingURL=legacy_view_bootstrap.js.map