var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/asset-registry/src/index.ts
__markAsModule(exports);
__export(exports, {
  LwrAssetRegistry: () => LwrAssetRegistry
});
var import_crypto = __toModule(require("crypto"));
var import_path = __toModule(require("path"));
var import_fs = __toModule(require("fs"));
var import_asset_linker = __toModule(require("./asset-linker.cjs"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var LwrAssetRegistry = class {
  constructor(context, lwrGlobalConfig) {
    this.name = "lwr-asset-registry";
    this.providers = [];
    const {assets, basePath, rootDir, layoutsDir, contentDir, cacheDir} = lwrGlobalConfig;
    this.basePath = basePath;
    this.resourcePaths = {assets, rootDir, layoutsDir, contentDir};
    this.cacheDir = (0, import_path.join)(cacheDir, import_shared_utils.ASSETS_CACHE_DIR);
    this.assetTransformers = [];
    this._memoizeResolveUri = this.resolveAssetUriWithoutLinking.bind(this);
  }
  async delegateGetAsset(assetIdentifier) {
    for (const provider of this.providers) {
      const result = await provider.getAsset(assetIdentifier);
      if (result) {
        return result;
      }
    }
    throw (0, import_diagnostics.createSingleDiagnosticError)({
      description: import_diagnostics.descriptions.UNRESOLVABLE.ASSET(assetIdentifier.specifier)
    }, import_diagnostics.LwrUnresolvableError);
  }
  addAssetProviders(providers) {
    this.providers.push(...providers);
  }
  addAssetTransformers(transformers) {
    this.assetTransformers.push(...transformers);
  }
  async getAsset(assetId, runtimeEnvironment, includeMetadata) {
    const rawAsset = await this.delegateGetAsset(assetId);
    if (rawAsset.noTransform) {
      const assetDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
      import_shared_utils.logger.debug(`[LwrAssetRegistry][getAsset] no-transform source ${assetId.specifier} -> ${assetDef.uri}`);
      return assetDef;
    }
    const overrideFilePath = this.getHashedAssetPath(rawAsset, runtimeEnvironment);
    if (!includeMetadata && (0, import_fs.existsSync)(overrideFilePath)) {
      return this.getAssetDefinition(rawAsset, runtimeEnvironment);
    }
    let assetSource = rawAsset.content();
    let pluginContext = {};
    for (const transformPlugin of this.assetTransformers) {
      const transformResult = await transformPlugin.transform?.(assetSource, rawAsset, pluginContext);
      if (transformResult) {
        if (Buffer.isBuffer(transformResult) || typeof transformResult === "string") {
          assetSource = transformResult;
        } else {
          assetSource = transformResult.code;
          pluginContext = {...pluginContext, ...transformResult.context};
        }
      }
    }
    for (const transformPlugin of this.assetTransformers) {
      const linkResult = await transformPlugin.extractMetadata?.(assetSource, rawAsset, pluginContext);
      if (linkResult) {
        pluginContext = {...pluginContext, ...linkResult.context};
        rawAsset.metadata = {...rawAsset.metadata, ...linkResult.metadata};
      }
    }
    assetSource = await (0, import_asset_linker.linkAsset)(assetSource, rawAsset, runtimeEnvironment, this._memoizeResolveUri);
    for (const transformPlugin of this.assetTransformers) {
      const optimizeResult = await transformPlugin.optimize?.(assetSource, rawAsset, pluginContext);
      if (optimizeResult) {
        if (typeof optimizeResult === "string" || Buffer.isBuffer(optimizeResult)) {
          assetSource = optimizeResult;
        } else {
          pluginContext = {...pluginContext, ...optimizeResult.context};
          assetSource = optimizeResult.code;
        }
      }
    }
    (0, import_fs.writeFileSync)(overrideFilePath, assetSource, "utf-8");
    const newDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
    import_shared_utils.logger.debug(`[LwrAssetRegistry][getAsset] fully processed ${assetId.specifier} -> ${newDef.uri}`);
    if (includeMetadata) {
      return {...newDef, metadata: rawAsset.metadata};
    } else {
      return newDef;
    }
  }
  getHashedAssetPath({ownHash, entry, type}, runtimeEnvironment) {
    const runtimeHash = [
      this.basePath,
      runtimeEnvironment.lwrVersion,
      type || "d",
      runtimeEnvironment.compat ? "c" : "",
      runtimeEnvironment.immutableAssets ? "i" : "",
      runtimeEnvironment.minify ? "m" : ""
    ].join("");
    const fullPathHash = import_crypto.default.createHash("sha1").update(`${entry}:${ownHash}`).digest("hex").toString();
    const hashedPath = (0, import_path.join)(this.cacheDir, `${runtimeHash}_${fullPathHash}_${(0, import_path.basename)(entry)}`);
    import_shared_utils.logger.debug(`[LwrAssetRegistry][getHashedAssetPath] ${runtimeHash} -> ${hashedPath}`);
    return hashedPath;
  }
  async getAssetDefinition(assetSource, runtimeEnvironment) {
    let collect;
    if (assetSource.noTransform) {
      collect = {
        type: assetSource.type || "external",
        uri: String(assetSource.uri),
        overrideFilePath: assetSource.entry
      };
      import_shared_utils.logger.debug(`[LwrAssetRegistry][getAssetDefinition] no transform url ${collect.type}, ${collect.uri}, ${assetSource.entry}`);
    } else {
      const {type: type2, uri: uri2} = this.validateSpecifier(assetSource.entry);
      const overrideFilePath2 = this.getHashedAssetPath(assetSource, runtimeEnvironment);
      collect = {
        type: assetSource.uri ? "external" : type2,
        uri: assetSource.uri || uri2,
        overrideFilePath: overrideFilePath2
      };
      import_shared_utils.logger.debug(`[LwrAssetRegistry][getAssetDefinition] url ${collect.uri}, ${collect.uri}, ${overrideFilePath2}`);
    }
    const {type, uri, overrideFilePath} = collect;
    return {
      ...assetSource,
      type,
      uri,
      stream: (encoding) => (0, import_fs.createReadStream)(overrideFilePath, {encoding}),
      content: (encoding) => (0, import_fs.readFileSync)(overrideFilePath, encoding)
    };
  }
  async resolveAssetUri(assetId, runtimeEnvironment) {
    const {specifier} = assetId;
    if ((0, import_shared_utils.isExternalUrl)(specifier)) {
      import_shared_utils.logger.debug(`[LwrAssetRegistry][resolveAssetUri] external url ${specifier}`);
      return {uri: specifier, entry: specifier, immutable: true, external: true};
    }
    const assetDef = await this.getAsset(assetId, runtimeEnvironment);
    if (assetDef.noTransform) {
      import_shared_utils.logger.debug(`[LwrAssetRegistry][resolveAssetUri] noTransform source ${specifier} -> ${assetDef.uri}`);
      return {
        uri: assetDef.uri,
        entry: assetDef.entry,
        immutable: true,
        external: (0, import_shared_utils.isAssetSourceExternal)(assetDef)
      };
    }
    const ret = (0, import_asset_linker.getUriFromAsset)(assetDef, runtimeEnvironment);
    import_shared_utils.logger.debug(`[LwrAssetRegistry][resolveAssetUri] getUriFromAsset ${specifier} -> ${ret.uri}`);
    return ret;
  }
  async resolveAssetUriWithoutLinking(assetId, runtimeEnvironment) {
    const {specifier} = assetId;
    if ((0, import_shared_utils.isExternalUrl)(specifier)) {
      import_shared_utils.logger.debug(`[LwrAssetRegistry][resolveAssetUriWithoutLinking] external url ${specifier}`);
      return {uri: specifier, entry: specifier, immutable: true, external: true};
    }
    const rawAsset = await this.delegateGetAsset(assetId);
    if (rawAsset.noTransform) {
      import_shared_utils.logger.debug(`[LwrAssetRegistry][resolveAssetUriWithoutLinking] noTransform source ${specifier} -> ${rawAsset.uri}`);
      return {
        uri: String(rawAsset.uri),
        entry: rawAsset.entry,
        immutable: true,
        external: (0, import_shared_utils.isAssetSourceExternal)(rawAsset)
      };
    }
    const assetDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
    const uri = (0, import_asset_linker.getUriFromAsset)(assetDef, runtimeEnvironment);
    import_shared_utils.logger.debug(`[LwrAssetRegistry][resolveAssetUri] getUriFromAsset ${specifier} -> ${assetDef.uri}`);
    return uri;
  }
  getPublicApi() {
    return {
      getAsset: this.getAsset.bind(this),
      resolveAssetUri: this.resolveAssetUri.bind(this)
    };
  }
  validateSpecifier(specifier) {
    if ((0, import_shared_utils.isExternalUrl)(specifier)) {
      return {
        type: "external",
        uri: specifier
      };
    }
    const {assets, contentDir} = this.resourcePaths;
    const assetsMap = assets.reduce((map, asset) => {
      const {alias, urlPath} = asset;
      if (alias) {
        const assetDir = asset;
        const fsPath = assetDir.dir ? assetDir.dir : asset.file;
        if (fsPath) {
          map[fsPath] = urlPath;
        }
      }
      return map;
    }, {});
    if (specifier.startsWith(contentDir)) {
      return {
        type: "content-asset",
        uri: (0, import_path.relative)(contentDir, specifier)
      };
    }
    for (const [fsPath, urlPath] of Object.entries(assetsMap)) {
      if (specifier.startsWith(fsPath)) {
        return {
          type: "asset",
          uri: specifier.replace(fsPath, urlPath)
        };
      }
    }
    return {
      type: "unknown",
      uri: specifier
    };
  }
};
