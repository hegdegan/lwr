import crypto from 'crypto';
import { join, relative, basename } from 'path';
import { createReadStream, existsSync, readFileSync, writeFileSync } from 'fs';
import { getUriFromAsset, linkAsset } from './asset-linker.js';
import { LwrUnresolvableError, createSingleDiagnosticError, descriptions } from '@lwrjs/diagnostics';
import { isExternalUrl, ASSETS_CACHE_DIR, logger, isAssetSourceExternal } from '@lwrjs/shared-utils';
export class LwrAssetRegistry {
    constructor(context, lwrGlobalConfig) {
        this.name = 'lwr-asset-registry';
        this.providers = [];
        const { assets, basePath, rootDir, layoutsDir, contentDir, cacheDir } = lwrGlobalConfig;
        this.basePath = basePath;
        this.resourcePaths = { assets, rootDir, layoutsDir, contentDir };
        this.cacheDir = join(cacheDir, ASSETS_CACHE_DIR);
        this.assetTransformers = [];
        this._memoizeResolveUri = this.resolveAssetUriWithoutLinking.bind(this);
    }
    async delegateGetAsset(assetIdentifier) {
        for (const provider of this.providers) {
            // eslint-disable-next-line no-await-in-loop
            const result = await provider.getAsset(assetIdentifier);
            if (result) {
                return result;
            }
        }
        throw createSingleDiagnosticError({
            description: descriptions.UNRESOLVABLE.ASSET(assetIdentifier.specifier),
        }, LwrUnresolvableError);
    }
    // -- Public API --------------------------------------------------------------------
    // Add new resource providers
    addAssetProviders(providers) {
        this.providers.push(...providers);
    }
    // Add new asset transformers
    addAssetTransformers(transformers) {
        this.assetTransformers.push(...transformers);
    }
    // Retrieve a resource from the providers and transform it though pipeline of plugins
    async getAsset(assetId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    runtimeEnvironment, includeMetadata) {
        const rawAsset = await this.delegateGetAsset(assetId);
        // Check if the source says it should not be transformed
        if (rawAsset.noTransform) {
            const assetDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
            logger.debug(`[LwrAssetRegistry][getAsset] no-transform source ${assetId.specifier} -> ${assetDef.uri}`);
            return assetDef;
        }
        const overrideFilePath = this.getHashedAssetPath(rawAsset, runtimeEnvironment);
        // Since metadata is not cached with the asset to include metadata we need to re-process
        if (!includeMetadata && existsSync(overrideFilePath)) {
            return this.getAssetDefinition(rawAsset, runtimeEnvironment);
        }
        // Note is important we guarantee the release of the assetSource string (no closures!)
        // Otherwise we will be putting all assets in memory which is problematic
        let assetSource = rawAsset.content();
        let pluginContext = {};
        // STEP 1: Apply asset transformations
        // In this hook you can modify the source arbitrarily @include file semantics
        // INVARIANT: return must be a parsable mimetype compliant source
        // ex (SASS -> CSS, LESS -> CSS, PNG -> PNG optimized, ...)
        for (const transformPlugin of this.assetTransformers) {
            // eslint-disable-next-line no-await-in-loop
            const transformResult = await transformPlugin.transform?.(assetSource, rawAsset, pluginContext);
            if (transformResult) {
                if (Buffer.isBuffer(transformResult) || typeof transformResult === 'string') {
                    assetSource = transformResult;
                }
                else {
                    assetSource = transformResult.code;
                    pluginContext = { ...pluginContext, ...transformResult.context };
                }
            }
        }
        // STEP 2: Apply metadata transformations
        // Here is where we "link" or "transform" the code
        // as long as the module semantics are not touched
        // (ex. you cant add links to more resources)
        for (const transformPlugin of this.assetTransformers) {
            // eslint-disable-next-line no-await-in-loop
            const linkResult = await transformPlugin.extractMetadata?.(assetSource, rawAsset, pluginContext);
            if (linkResult) {
                pluginContext = { ...pluginContext, ...linkResult.context };
                rawAsset.metadata = { ...rawAsset.metadata, ...linkResult.metadata };
            }
        }
        // STEP 3.0: TBD: Potentially expose a "linking" phase to user-land ??
        // STEP 3.1: Link the asset (rewrite the file based on metadata)
        // Note that some of the metadata might no longer be accurate (ex. import locations) after this step
        assetSource = await linkAsset(assetSource, rawAsset, runtimeEnvironment, this._memoizeResolveUri);
        // STEP 4:  Optimize asset transformations
        // Here we do minimization, compression, obfuscation, ...
        // This should also not change the semantics of the file (ex. imports)
        for (const transformPlugin of this.assetTransformers) {
            // eslint-disable-next-line no-await-in-loop
            const optimizeResult = await transformPlugin.optimize?.(assetSource, rawAsset, pluginContext);
            if (optimizeResult) {
                if (typeof optimizeResult === 'string' || Buffer.isBuffer(optimizeResult)) {
                    assetSource = optimizeResult;
                }
                else {
                    pluginContext = { ...pluginContext, ...optimizeResult.context };
                    assetSource = optimizeResult.code;
                }
            }
        }
        // STEP 5: Store the modified/transformed version of the asset
        writeFileSync(overrideFilePath, assetSource, 'utf-8');
        // STEP 6: Normalize and augment the asset and return the full definition
        const newDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
        logger.debug(`[LwrAssetRegistry][getAsset] fully processed ${assetId.specifier} -> ${newDef.uri}`);
        if (includeMetadata) {
            return { ...newDef, metadata: rawAsset.metadata };
        }
        else {
            return newDef;
        }
    }
    getHashedAssetPath({ ownHash, entry, type }, runtimeEnvironment) {
        const runtimeHash = [
            this.basePath,
            runtimeEnvironment.lwrVersion,
            type || 'd',
            runtimeEnvironment.compat ? 'c' : '',
            runtimeEnvironment.immutableAssets ? 'i' : '',
            runtimeEnvironment.minify ? 'm' : '',
        ].join('');
        // Create a hash based on the full path plus the own hash from the provider.
        // The FS provider own hash is just the last time the file was saved.
        const fullPathHash = crypto.createHash('sha1').update(`${entry}:${ownHash}`).digest('hex').toString();
        const hashedPath = join(this.cacheDir, `${runtimeHash}_${fullPathHash}_${basename(entry)}`);
        logger.debug(`[LwrAssetRegistry][getHashedAssetPath] ${runtimeHash} -> ${hashedPath}`);
        return hashedPath;
    }
    async getAssetDefinition(assetSource, runtimeEnvironment) {
        let collect;
        if (assetSource.noTransform) {
            collect = {
                type: assetSource.type || 'external',
                uri: String(assetSource.uri),
                overrideFilePath: assetSource.entry,
            };
            logger.debug(`[LwrAssetRegistry][getAssetDefinition] no transform url ${collect.type}, ${collect.uri}, ${assetSource.entry}`);
        }
        else {
            const { type, uri } = this.validateSpecifier(assetSource.entry);
            const overrideFilePath = this.getHashedAssetPath(assetSource, runtimeEnvironment);
            collect = {
                type: assetSource.uri ? 'external' : type,
                uri: assetSource.uri || uri,
                overrideFilePath,
            };
            logger.debug(`[LwrAssetRegistry][getAssetDefinition] url ${collect.uri}, ${collect.uri}, ${overrideFilePath}`);
        }
        const { type, uri, overrideFilePath } = collect;
        return {
            ...assetSource,
            type,
            uri,
            // NOTE: The "entry" field still points to the old fs path.
            // If we were to change it, we need to reconcile it with the metadata delivery on HMR
            stream: (encoding) => createReadStream(overrideFilePath, { encoding }),
            content: (encoding) => readFileSync(overrideFilePath, encoding),
        };
    }
    // Given a resource and environment, return a resource URI
    async resolveAssetUri(assetId, runtimeEnvironment) {
        const { specifier } = assetId;
        // If the asset is an external URL there is nothing to do
        if (isExternalUrl(specifier)) {
            logger.debug(`[LwrAssetRegistry][resolveAssetUri] external url ${specifier}`);
            return { uri: specifier, entry: specifier, immutable: true, external: true };
        }
        const assetDef = await this.getAsset(assetId, runtimeEnvironment);
        if (assetDef.noTransform) {
            logger.debug(`[LwrAssetRegistry][resolveAssetUri] noTransform source ${specifier} -> ${assetDef.uri}`);
            return {
                uri: assetDef.uri,
                entry: assetDef.entry,
                immutable: true,
                external: isAssetSourceExternal(assetDef),
            };
        }
        const ret = getUriFromAsset(assetDef, runtimeEnvironment);
        logger.debug(`[LwrAssetRegistry][resolveAssetUri] getUriFromAsset ${specifier} -> ${ret.uri}`);
        return ret;
    }
    // Given a resource and environment, return a resource URI with out deep linking (which could result in cycles)
    async resolveAssetUriWithoutLinking(assetId, runtimeEnvironment) {
        const { specifier } = assetId;
        // If the asset is an external URL there is nothing to do
        if (isExternalUrl(specifier)) {
            logger.debug(`[LwrAssetRegistry][resolveAssetUriWithoutLinking] external url ${specifier}`);
            return { uri: specifier, entry: specifier, immutable: true, external: true };
        }
        const rawAsset = await this.delegateGetAsset(assetId);
        if (rawAsset.noTransform) {
            logger.debug(`[LwrAssetRegistry][resolveAssetUriWithoutLinking] noTransform source ${specifier} -> ${rawAsset.uri}`);
            return {
                uri: String(rawAsset.uri),
                entry: rawAsset.entry,
                immutable: true,
                external: isAssetSourceExternal(rawAsset),
            };
        }
        const assetDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
        const uri = getUriFromAsset(assetDef, runtimeEnvironment);
        logger.debug(`[LwrAssetRegistry][resolveAssetUri] getUriFromAsset ${specifier} -> ${assetDef.uri}`);
        return uri;
    }
    getPublicApi() {
        return {
            getAsset: this.getAsset.bind(this),
            resolveAssetUri: this.resolveAssetUri.bind(this),
        };
    }
    validateSpecifier(specifier) {
        // If is a URL
        if (isExternalUrl(specifier)) {
            return {
                type: 'external',
                uri: specifier,
            };
        }
        const { assets, contentDir } = this.resourcePaths;
        const assetsMap = assets.reduce((map, asset) => {
            const { alias, urlPath } = asset;
            if (alias) {
                const assetDir = asset;
                const fsPath = assetDir.dir ? assetDir.dir : asset.file;
                if (fsPath) {
                    map[fsPath] = urlPath;
                }
            }
            return map;
        }, {});
        if (specifier.startsWith(contentDir)) {
            return {
                type: 'content-asset',
                uri: relative(contentDir, specifier),
            };
        }
        for (const [fsPath, urlPath] of Object.entries(assetsMap)) {
            if (specifier.startsWith(fsPath)) {
                return {
                    type: 'asset',
                    uri: specifier.replace(fsPath, urlPath),
                };
            }
        }
        return {
            type: 'unknown',
            uri: specifier,
        };
    }
}
//# sourceMappingURL=index.js.map