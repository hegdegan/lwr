import { GraphDepth, getModuleGraphs, getSpecifier } from '@lwrjs/shared-utils';
import { rollup } from 'rollup';
import replace from '@rollup/plugin-replace';
// import { terser } from 'rollup-plugin-terser';
import { bundleDefinitions } from './rollup-amd-bundler-plugin.js';
import { overrideBundleConfig } from './bundle-common.js';
const AMD_DEFINE = 'LWR.define';
async function bundle(id, moduleGraphs, minify = false) {
    const plugins = [bundleDefinitions({ moduleGraphs })];
    minify &&
        plugins.push(
        // terser(), // Do not minify until needed for client modules. Server/SSR modules do not need to be minifed.
        replace({
            'process.env.NODE_ENV': JSON.stringify('production'),
            preventAssignment: false,
        }));
    const bundler = await rollup({ input: id, plugins });
    const { output } = await bundler.generate({
        amd: { id, define: AMD_DEFINE },
        exports: 'named',
        format: 'amd',
    });
    return output[0].code;
}
export async function amdBundler(moduleId, moduleRegistry, minify = false, runtimeEnvironment, runtimeParams = {}, { bundleConfig }, bundleConfigOverrides) {
    const { exclude, external = {} } = overrideBundleConfig(bundleConfig, bundleConfigOverrides);
    const externalsArray = Object.keys(external);
    const requiredImports = new Map();
    const dynamicImports = new Map();
    const includedModules = [];
    const graphOptions = {
        includeLinkedDefinitions: true,
        depth: {
            static: GraphDepth.ALL,
            dynamic: 0,
            includeId: (moduleRef) => {
                // Do not bundle externals, including the loader module, which is auto bundled
                // with the shim + loader combo
                if (externalsArray.includes(moduleRef.specifier)) {
                    // Do not include externals in the required imports but also return false to indicate it should not be in the bundle
                    return false;
                }
                else if (exclude?.includes(moduleRef.specifier)) {
                    // If this is a bundle exclude return false to indicate it should not be in the bundle
                    // but add it to the requriedImports so it shows up as a static dependency of the bundle.
                    requiredImports.set(`${moduleRef.specifier}_${moduleRef.version}`, moduleRef);
                    return false;
                }
                return true;
            },
        },
    };
    const moduleGraphs = await getModuleGraphs(moduleId.specifier, graphOptions, moduleRegistry, moduleRegistry, runtimeEnvironment, runtimeParams);
    const rootModule = moduleGraphs.graphs[0];
    const modules = [rootModule.specifier, ...moduleGraphs.graphs[0].static];
    const bundles = await Promise.all(modules
        .reduce((filteredModules, specifier) => {
        const linkedDefinition = moduleGraphs.linkedDefinitions[specifier];
        // skip modules that do not have a linked definition
        if (!linkedDefinition) {
            return filteredModules;
        }
        // add any dynamic imports from each of the linked definitions in the module graph
        linkedDefinition.linkedModuleRecord.dynamicImports?.forEach((dynamicImport) => {
            if (dynamicImport.moduleNameType !== 'unresolved') {
                dynamicImports.set(`${dynamicImport.specifier}_${dynamicImport.version}`, dynamicImport);
            }
        });
        // skip relative dependencies
        if (specifier.includes('#')) {
            return filteredModules;
        }
        // prepend the linked definition for the correct order
        filteredModules.unshift(linkedDefinition);
        return filteredModules;
    }, [])
        .map((linkedDefinition) => {
        const id = getSpecifier(linkedDefinition);
        if (id !== rootModule.specifier) {
            includedModules.push(id);
        }
        // bundle all dependencies for the linked definition and convert to AMD
        return bundle(id, moduleGraphs, minify);
    }));
    const { id, name, namespace, version, specifier } = moduleGraphs.linkedDefinitions[rootModule.specifier];
    return {
        id,
        name,
        namespace,
        version,
        specifier,
        code: bundles.join(''),
        config: { external, exclude },
        bundleRecord: {
            imports: Array.from(requiredImports.values()),
            dynamicImports: Array.from(dynamicImports.values()),
            includedModules,
        },
    };
}
//# sourceMappingURL=amd-common.js.map